# Pabawi v1.0.0 - Modular Plugin Architecture Plan

**Status:** Draft for Review  
**Created:** 2026-01-31  
**Target Version:** 1.0.0

## Executive Summary

This plan describes a complete architectural refactoring of Pabawi to support a modular, extensible plugin system with:

- **Full-stack plugins** providing backend capabilities, frontend widgets, and CLI commands
- **Capability-based interface** replacing type-based plugin categories
- **RBAC (Role-Based Access Control)** enforced across Web UI, REST API, and CLI
- **Declarative YAML configuration** with environment variable overrides
- **Dynamic UI composition** with permission-aware plugin widgets
- **Extensible CLI** with auto-generated commands from plugin schemas
- **Debug mode** with correlation tracking across all interfaces
- **Database abstraction layer** for future database engine support
- **Plugin marketplace readiness** for third-party integrations

## Architecture Overview

### Three-Interface Platform

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Pabawi Platform                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Web UI   â”‚      â”‚ REST API â”‚      â”‚   CLI    â”‚      â”‚
â”‚  â”‚ (Svelte) â”‚      â”‚ (Express)â”‚      â”‚  (Node)  â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜      â”‚
â”‚       â”‚                 â”‚                  â”‚            â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                         â”‚                               â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚              â”‚ Plugin System       â”‚                    â”‚
â”‚              â”‚ - Capability Reg.   â”‚                    â”‚
â”‚              â”‚ - RBAC Engine       â”‚                    â”‚
â”‚              â”‚ - Widget Registry   â”‚                    â”‚
â”‚              â”‚ - Integration Mgr   â”‚                    â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                         â”‚                               â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚       â”‚                 â”‚                 â”‚            â”‚
â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Bolt   â”‚       â”‚PuppetDB â”‚       â”‚ Hiera  â”‚       â”‚
â”‚  â”‚ Plugin  â”‚       â”‚ Plugin  â”‚       â”‚ Plugin â”‚       â”‚
â”‚  â”‚         â”‚       â”‚         â”‚       â”‚        â”‚       â”‚
â”‚  â”‚Backend  â”‚       â”‚Backend  â”‚       â”‚Backend â”‚       â”‚
â”‚  â”‚Frontend â”‚       â”‚Frontend â”‚       â”‚Frontendâ”‚       â”‚
â”‚  â”‚CLI Cmds â”‚       â”‚CLI Cmds â”‚       â”‚CLI Cmdsâ”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  External Plugins (npm packages / local dirs)   â”‚  â”‚
â”‚  â”‚  @pabawi-plugins/ansible                        â”‚  â”‚
â”‚  â”‚  @pabawi-plugins/terraform                      â”‚  â”‚
â”‚  â”‚  backend/src/integrations/custom-plugin/        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Plugin Structure

Every plugin can provide:

1. **Backend Capabilities**: Functions that perform actions (execute commands, query data, compile configs)
2. **Frontend Widgets**: Svelte components that render in UI slots
3. **CLI Commands**: Command definitions with argument schemas

```
@pabawi-plugins/example/
â”œâ”€â”€ package.json                   # Plugin metadata
â”œâ”€â”€ backend/
â”‚   â””â”€â”€ index.ts                   # createPlugin() export
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ index.ts                   # Widget exports
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ ExampleWidget.svelte
â”‚   â”‚   â””â”€â”€ ExamplePanel.svelte
â”‚   â””â”€â”€ stores/
â”‚       â””â”€â”€ exampleState.svelte.ts
â””â”€â”€ cli/
    â””â”€â”€ commands.ts                # CLI command definitions (optional)
```

## Implementation Steps

### Phase 1: Core Plugin Infrastructure (Weeks 1-2)

#### Step 1: Define Enhanced Plugin Interfaces

**File:** `backend/src/integrations/types.ts`

**Actions:**

- Remove deprecated `ExecutionToolPlugin` and `InformationSourcePlugin` interfaces (clean break)
- Define `PluginMetadata` interface:

  ```typescript
  interface PluginMetadata {
    name: string;
    version: string;
    author: string;
    description: string;
    homepage?: string;
    dependencies?: string[];        // Other plugin dependencies
    frontendEntryPoint?: string;    // Path to frontend bundle
    cliCommands?: PluginCLICommand[];
  }
  ```

- Define `PluginCapability` interface:

  ```typescript
  interface PluginCapability {
    category: string;                // 'command', 'task', 'facts', 'config'
    name: string;                    // 'command.execute'
    description: string;
    handler: (params: any, context: ExecutionContext) => Promise<any>;
    requiredPermissions: string[];
    riskLevel: 'read' | 'write' | 'execute' | 'admin';
    schema?: CapabilitySchema;       // Zod schema for validation
  }
  
  interface CapabilitySchema {
    arguments: Record<string, ArgumentDefinition>;
    returns: {
      type: string;
      description: string;
      schema?: ZodSchema;
    };
  }
  
  interface ArgumentDefinition {
    type: 'string' | 'number' | 'boolean' | 'array' | 'object';
    description: string;
    required: boolean;
    default?: any;
    choices?: any[];
    validation?: ZodSchema;
  }
  ```

- Define `PluginWidget` interface:

  ```typescript
  interface PluginWidget {
    id: string;                      // 'bolt:command-executor'
    name: string;
    component: string;               // Component path
    slots: WidgetSlot[];             // Where it can render
    size: 'small' | 'medium' | 'large' | 'full';
    requiredCapabilities: string[];  // For permission checks
    config?: Record<string, unknown>;
  }
  
  type WidgetSlot = 
    | 'dashboard' 
    | 'node-detail' 
    | 'inventory-panel' 
    | 'standalone-page';
  ```

- Define `PluginCLICommand` interface:

  ```typescript
  interface PluginCLICommand {
    name: string;                    // 'bolt', 'puppetdb'
    actions: CLIAction[];
  }
  
  interface CLIAction {
    name: string;                    // 'run', 'query'
    capability: string;              // Maps to capability name
    description: string;
    aliases?: string[];
    examples?: string[];
  }
  ```

- Expand `IntegrationType` enum:

  ```typescript
  enum IntegrationType {
    Provisioning = 'Provisioning',
    ConfigurationManagement = 'ConfigurationManagement',
    InventorySource = 'InventorySource',
    RemoteExecution = 'RemoteExecution',
    Monitoring = 'Monitoring',
    Orchestration = 'Orchestration',
    SecretManagement = 'SecretManagement', #pragma: allowlist secret
    ReportingAnalytics = 'ReportingAnalytics',
    AuditCompliance = 'AuditCompliance',
    BackupRecovery = 'BackupRecovery'
  }
  ```

- Define unified `BasePluginInterface`:

  ```typescript
  interface BasePluginInterface {
    metadata: PluginMetadata;
    capabilities: PluginCapability[];
    widgets?: PluginWidget[];
    cliCommands?: PluginCLICommand[];
    configSchema?: ZodSchema;
    defaultPermissions?: Record<string, string[]>;  // capability -> roles
    
    initialize(): Promise<void>;
    healthCheck(): Promise<HealthCheckResult>;
    getConfig(): Record<string, unknown>;
    isInitialized(): boolean;
  }
  ```

#### Step 2: Build Capability Registry

**File:** `backend/src/integrations/CapabilityRegistry.ts`

**Actions:**

- Create registry mapping capability names to plugin handlers
- Implement methods:
  - `registerCapability(pluginName: string, capability: PluginCapability)`
  - `getProvidersForCapability(capabilityName: string): PluginCapability[]`
  - `getAllCapabilities(user?: User): PluginCapability[]` (permission-filtered)
  - `executeCapability(user: User, capabilityName: string, params: any, debugContext?: DebugContext): Promise<any>`
- Support priority-based routing when multiple plugins provide same capability
- Link widgets to capabilities for permission resolution

#### Step 3: Implement Plugin Loader

**File:** `backend/src/integrations/PluginLoader.ts`

**Actions:**

- Scan directories: `backend/src/integrations/` and `node_modules/@pabawi-plugins/*/`
- Load plugins via `require()` or dynamic `import()`
- Validate plugin structure against interfaces
- Resolve dependency graph (e.g., Hiera requires PuppetDB)
- Extract frontend metadata and CLI definitions
- Return loaded plugin instances with metadata

**Key Methods:**

- `async loadAll(): Promise<Plugin[]>`
- `async loadPlugin(path: string): Promise<Plugin>`
- `validatePlugin(plugin: Plugin): void`
- `resolveDependencies(plugins: Plugin[]): Plugin[]` (topological sort)

#### Step 4: Refactor Integration Manager âœ… COMPLETED

**File:** `backend/src/integrations/IntegrationManager.ts`

**Status:** Completed 2026-01-31

**Breaking Changes (Implemented as Deprecations):**

- âœ… Marked `executionTools` and `informationSources` Maps as deprecated
- âœ… Legacy methods (`getExecutionTool`, `getInformationSource`, etc.) now log deprecation warnings
- âœ… Added capability-based routing via `executeCapability()`

**New Architecture (Implemented):**

- âœ… Uses `CapabilityRegistry` for all capability-based operations
- âœ… Uses `PluginLoader` for v1.0.0 plugin discovery and loading
- âœ… `initializePlugins()` now initializes both legacy and v1.0.0 plugins
- âœ… Added `getInventoryViaCapability()` for capability-based inventory access
- âœ… Added `getNodeFactsViaCapability()` for capability-based facts access

**Updated Methods:**

- âœ… `async initializePlugins(options?)`: Supports both legacy and v1.0.0 plugin loading
- âœ… `async executeCapability(user, capabilityName, params, debugContext)`: Routes to CapabilityRegistry
- âœ… `getPluginMetadata(pluginName)`: Returns plugin metadata
- âœ… `async reloadPlugin(pluginName)`: Hot-reload support

**Deprecated (will be removed in v2.0.0):**

- `getExecutionTool()` - Use `executeCapability('command.execute', ...)`
- `getInformationSource()` - Use `executeCapability('inventory.list', ...)`
- `getAllExecutionTools()` - Use `getCapabilitiesByCategory('command')`
- `getAllInformationSources()` - Use `getCapabilitiesByCategory('inventory')`

#### Step 5: Create Database Abstraction Layer âœ… COMPLETED

**Status:** Completed 2026-01-31

**Files Created:**

- âœ… `backend/src/database/interfaces/DatabaseInterface.ts` - Core interfaces
- âœ… `backend/src/database/adapters/SQLiteAdapter.ts` - SQLite implementation
- âœ… `backend/src/database/DatabaseFactory.ts` - Adapter factory
- âœ… `backend/src/database/index.ts` - Barrel exports
- ðŸ”® `backend/src/database/adapters/PostgreSQLAdapter.ts` (future)

**Actions Completed:**

- âœ… Defined `DatabaseAdapter` interface with connection, transaction, query, and schema methods
- âœ… Defined `DatabaseConfig` interface supporting SQLite, PostgreSQL, MySQL
- âœ… Implemented `SQLiteAdapter` with full interface compliance
- âœ… Created `DatabaseFactory` for adapter instantiation
- âœ… Updated `DatabaseService` to use adapter pattern (with backward compatibility)
- âœ… Added `DatabaseConfigSchema` to config/schema.ts
- âœ… Updated `AppConfigSchema` with optional `database` configuration
- âœ… Maintained backward compatibility with legacy `databasePath` string option
- âœ… `ExecutionRepository` continues to work via `getConnection()` deprecation bridge

**Breaking Changes:** None (fully backward compatible)

**New Capabilities:**

- Transaction support (`beginTransaction`, `commit`, `rollback`, `withTransaction`)
- Health checks (`healthCheck()`)
- Database dialect awareness (`getDialect()`)
- Migration framework with versioning
- Extensible adapter registration for plugins

**Database Interface Summary:**

```typescript
export interface DatabaseAdapter {
  // Connection management
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  isConnected(): boolean;
  
  // Transaction support
  beginTransaction(): Promise<void>;
  commit(): Promise<void>;
  rollback(): Promise<void>;
  
  // Query execution
  query<T>(sql: string, params?: any[]): Promise<T[]>;
  execute(sql: string, params?: any[]): Promise<{ changes: number; lastID?: number }>;
  
  // Schema management
  migrate(migrations: Migration[]): Promise<void>;
  getCurrentVersion(): Promise<number>;
  
  // Utility methods
  escape(value: any): string;
  getDialect(): 'sqlite' | 'postgresql' | 'mysql';
}

export interface Migration {
  version: number;
  name: string;
  up: string;
  down: string;
}

export interface DatabaseConfig {
  type: 'sqlite' | 'postgresql' | 'mysql';
  // SQLite
  path?: string;
  // PostgreSQL/MySQL
  host?: string;
  port?: number;
  database?: string;
  username?: string;
  password?: string;
  ssl?: boolean;
  // Common
  poolMin?: number;
  poolMax?: number;
  connectionTimeout?: number;
}
```

**SQLiteAdapter.ts** - Current implementation:

```typescript
export class SQLiteAdapter implements DatabaseAdapter {
  private db: Database | null = null;
  
  constructor(private config: DatabaseConfig) {}
  
  async connect(): Promise<void> {
    this.db = new Database(this.config.path);
    // Enable foreign keys, WAL mode, etc.
  }
  
  async query<T>(sql: string, params?: any[]): Promise<T[]> {
    return this.db.prepare(sql).all(params);
  }
  
  async execute(sql: string, params?: any[]): Promise<{ changes: number; lastID?: number }> {
    const result = this.db.prepare(sql).run(params);
    return { changes: result.changes, lastID: result.lastInsertRowid };
  }
  
  getDialect(): 'sqlite' { return 'sqlite'; }
  
  // ... other methods
}
```

**DatabaseFactory.ts** - Adapter selection:

```typescript
export class DatabaseFactory {
  static create(config: DatabaseConfig): DatabaseAdapter {
    switch (config.type) {
      case 'sqlite':
        return new SQLiteAdapter(config);
      case 'postgresql':
        // Future: return new PostgreSQLAdapter(config);
        throw new Error('PostgreSQL adapter not yet implemented');
      default:
        throw new Error(`Unsupported database type: ${config.type}`);
    }
  }
}
```

**Update DatabaseService.ts:**

```typescript
export class DatabaseService {
  private adapter: DatabaseAdapter;
  
  constructor(config: DatabaseConfig) {
    this.adapter = DatabaseFactory.create(config);
  }
  
  async initialize() {
    await this.adapter.connect();
    await this.runMigrations();
  }
  
  // Delegate all operations to adapter
  async query<T>(sql: string, params?: any[]): Promise<T[]> {
    return this.adapter.query<T>(sql, params);
  }
  
  // ... other methods
}
```

**Configuration support in schema.ts:**

```typescript
const DatabaseConfigSchema = z.object({
  type: z.enum(['sqlite', 'postgresql', 'mysql']).default('sqlite'),
  path: z.string().optional(),  // SQLite
  host: z.string().optional(),  // PostgreSQL/MySQL
  port: z.number().optional(),
  database: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  ssl: z.boolean().optional(),
  poolMin: z.number().default(2),
  poolMax: z.number().default(10),
});
```

**Benefits:**

- **Current:** SQLite works as-is with minimal changes
- **Future:** Easy to add PostgreSQL, MySQL, or other databases
- **Abstraction:** All database-specific code isolated in adapters
- **Migration:** Query builders can be database-aware (handle syntax differences)
- **Testing:** Mock adapter for unit tests

### Phase 2: Authentication & Authorization (Week 3)

#### Step 6: Create User Management System

**Files:**

- `backend/src/auth/types.ts`
- `backend/src/auth/UserService.ts`
- `backend/src/auth/GroupService.ts`
- `backend/src/auth/RoleService.ts`

**Actions:**

- Define models:

  ```typescript
  interface User {
    id: string;
    username: string;
    email: string;
    passwordHash: string;
    groups: string[];
    roles: string[];
    active: boolean;
    createdAt: Date;
  }
  
  interface Group {
    id: string;
    name: string;
    description: string;
    roles: string[];
    members: string[];
    createdAt: Date;
  }
  
  interface Role {
    id: string;
    name: string;
    description: string;
    permissions: Permission[];
    priority: number;
    createdAt: Date;
  }
  
  interface Permission {
    capability: string;              // 'command.execute' or '*'
    action: 'allow' | 'deny';
    conditions?: PermissionCondition;
  }
  
  interface PermissionCondition {
    nodeFilter?: string;             // 'environment=dev'
    timeWindow?: string;
    ipRestriction?: string[];
  }
  ```

- Create database schema in `backend/src/database/schema.sql`:

  ```sql
  CREATE TABLE users (
    id TEXT PRIMARY KEY,
    username TEXT UNIQUE NOT NULL,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    active INTEGER DEFAULT 1,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  );
  
  CREATE TABLE groups (
    id TEXT PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  );
  
  CREATE TABLE roles (
    id TEXT PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    priority INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  );
  
  CREATE TABLE permissions (
    id TEXT PRIMARY KEY,
    role_id TEXT NOT NULL,
    capability TEXT NOT NULL,
    action TEXT NOT NULL,  -- 'allow' or 'deny'
    conditions TEXT,       -- JSON
    FOREIGN KEY (role_id) REFERENCES roles(id)
  );
  
  CREATE TABLE user_groups (
    user_id TEXT NOT NULL,
    group_id TEXT NOT NULL,
    PRIMARY KEY (user_id, group_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (group_id) REFERENCES groups(id)
  );
  
  CREATE TABLE user_roles (
    user_id TEXT NOT NULL,
    role_id TEXT NOT NULL,
    PRIMARY KEY (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (role_id) REFERENCES roles(id)
  );
  
  CREATE TABLE group_roles (
    group_id TEXT NOT NULL,
    role_id TEXT NOT NULL,
    PRIMARY KEY (group_id, role_id),
    FOREIGN KEY (group_id) REFERENCES groups(id),
    FOREIGN KEY (role_id) REFERENCES roles(id)
  );
  ```

- Implement services with bcrypt password hashing, CRUD operations

#### Step 7: Build Authentication Service

**File:** `backend/src/auth/AuthService.ts`

**Actions:**

- Implement JWT-based authentication
- Methods:
  - `async authenticate(username: string, password: string): Promise<AuthTokens>`
  - `async validateToken(token: string): Promise<User>`
  - `async refreshToken(refreshToken: string): Promise<AuthTokens>`
  - `async revokeToken(token: string): Promise<void>`
  - `generateToken(user: User): AuthTokens`

- Use `jsonwebtoken` library
- Token structure:

  ```typescript
  interface AuthTokens {
    accessToken: string;   // Short-lived (1 hour)
    refreshToken: string;  // Long-lived (7 days)
    expiresIn: number;
  }
  
  interface JWTPayload {
    userId: string;
    username: string;
    roles: string[];
    iat: number;
    exp: number;
  }
  ```

- Maintain token revocation list (in database via DatabaseAdapter)

#### Step 8: Implement Authorization Service

**File:** `backend/src/auth/AuthorizationService.ts`

**Actions:**

- Core method: `async checkPermission(user: User, capability: string, context?: ExecutionContext): Promise<boolean>`
- Algorithm:
  1. Resolve user's effective roles (direct + via groups)
  2. Collect all permissions for those roles
  3. Sort by priority (deny > allow)
  4. Evaluate conditions (node filters, time windows)
  5. Return true if allowed, false otherwise

- Helper methods:
  - `getEffectivePermissions(user: User): Permission[]`
  - `checkWidgetAccess(user: User, widgetId: string): boolean`
  - `filterCapabilitiesByPermissions(capabilities: PluginCapability[], user: User): PluginCapability[]`

- Implement caching with TTL (5 minutes default, invalidate on role changes)

#### Step 9: Add Authentication Middleware

**Files:**

- `backend/src/middleware/auth.ts`
- `backend/src/middleware/rbac.ts`

**Actions:**

- Create middleware for authentication and authorization
- Apply to all routes requiring auth
- Support optional authentication for public endpoints

#### Step 10: Create Auth Routes

**File:** `backend/src/routes/auth.ts`

**Actions:**

- Implement endpoints:
  - `POST /api/auth/login` (username, password â†’ tokens)
  - `POST /api/auth/refresh` (refreshToken â†’ new tokens)
  - `POST /api/auth/logout` (revoke tokens)
  - `GET /api/auth/me` (current user + effective permissions)

#### Step 11: Create RBAC Management Routes

**Files:**

- `backend/src/routes/users.ts`
- `backend/src/routes/groups.ts`
- `backend/src/routes/roles.ts`

**Actions:**

- Implement CRUD endpoints for users, groups, roles
- All routes require admin role

### Phase 3: Configuration System (Week 4)

#### Step 12: Build YAML Configuration Support

**File:** `backend/src/config/ConfigService.ts`

**Actions:**

- Add YAML parsing with `yaml` package
- Load configuration from:
  1. `backend/config/integrations.yaml`
  2. `backend/config/rbac.yaml`
  3. Environment variables (override YAML)

- Implement env var interpolation:

  ```yaml
  integrations:
    puppetdb:
      config:
        serverUrl: ${PUPPETDB_SERVER_URL}
        token: ${PUPPETDB_TOKEN:-default-token}
  ```

- Precedence: CLI args > env vars > YAML > defaults

#### Step 13: Create Configuration Schemas

**File:** `backend/src/config/schema.ts`

**Actions:**

- Define Zod schemas for YAML validation
- Per-plugin schema registration
- Update existing schemas to use registry

#### Step 14: Create Example YAML Configs

**Files:**

- `backend/config/integrations.yaml.example`
- `backend/config/rbac.yaml.example`
- `backend/config/database.yaml.example`

**integrations.yaml.example:**

```yaml
integrations:
  bolt:
    enabled: true
    priority: 5
    frontend:
      widgets:
        - id: bolt:command-executor
          enabled: true
          defaultSlots: [dashboard, node-detail]
    defaultPermissions:
      command.execute: [admin, operator]
      task.execute: [admin, operator]
    config:
      projectPath: ./
      timeout: 300000

  puppetdb:
    enabled: true
    priority: 10
    defaultPermissions:
      facts.query: [admin, operator, viewer]
    config:
      serverUrl: ${PUPPETDB_SERVER_URL}
      token: ${PUPPETDB_TOKEN}
```

**database.yaml.example:**

```yaml
database:
  # Current: SQLite (default)
  type: sqlite
  path: ./data/pabawi.db
  
  # Future: PostgreSQL
  # type: postgresql
  # host: localhost
  # port: 5432
  # database: pabawi
  # username: pabawi
  # password: ${DATABASE_PASSWORD}
  # ssl: true
  # poolMin: 2
  # poolMax: 10
```

### Phase 4: Frontend Plugin System (Weeks 5-6)

#### Step 15: Create Frontend Plugin Loader

**File:** `frontend/src/lib/plugins/PluginLoader.ts`

**Actions:**

- Dynamic import system for plugin bundles
- Handle loading errors gracefully
- Validate widget definitions

#### Step 16: Build Widget Registry

**File:** `frontend/src/lib/plugins/WidgetRegistry.svelte.ts`

**Actions:**

- Create centralized widget registry
- Filter widgets by user permissions
- Support slot-based widget retrieval

#### Step 17: Create Widget Slot Component

**File:** `frontend/src/lib/plugins/WidgetSlot.svelte`

**Actions:**

- Render widgets in designated slots
- Support different layouts (grid, stack, tabs)
- Lazy load widget components

#### Step 18: Implement Debug Mode

**Files:**

- `frontend/src/lib/debug/debugMode.svelte.ts` (rename from expertMode)
- `frontend/src/lib/debug/useDebugContext.ts`
- `frontend/src/components/DebugPanel.svelte`

**Actions:**

- Rename expert mode to debug mode
- Create debug context per widget
- Track API requests with correlation IDs

#### Step 19: Build Authentication Store

**File:** `frontend/src/lib/auth.svelte.ts`

**Actions:**

- Implement login, logout, token refresh
- Store user and permissions
- Check permissions reactively

#### Step 20: Create Permission Guard Component

**File:** `frontend/src/components/PermissionGuard.svelte`

**Actions:**

- Conditionally render based on capabilities
- Support fallback rendering
- Integrate with auth store

#### Step 21: Build Dynamic Menu System

**File:** `frontend/src/lib/navigation/MenuBuilder.svelte.ts`

**Actions:**

- Generate menu from loaded plugins
- Group by integration type
- Filter by user permissions

#### Step 22: Update Page Components

**Files:**

- `frontend/src/pages/DashboardPage.svelte`
- `frontend/src/pages/InventoryPage.svelte`
- `frontend/src/pages/PluginManagerPage.svelte`
- `frontend/src/pages/LoginPage.svelte`

**Actions:**

- Add widget slots to pages
- Create plugin management UI
- Implement login page

### Phase 5: CLI Application (Week 7)

#### Step 23: Create CLI Workspace Structure

**Actions:**

- Add CLI workspace to root package.json
- Create cli/package.json with dependencies
- Set up TypeScript configuration

#### Step 24: Build CLI Configuration

**File:** `cli/src/config/CliConfig.ts`

**Actions:**

- Use `conf` package for `~/.pabawirc` management
- Store server URL, tokens, preferences
- Support multiple configuration profiles

#### Step 25: Create API Client

**Files:**

- `cli/src/client/ApiClient.ts`
- `cli/src/client/AuthClient.ts`

**Actions:**

- REST API wrapper with authentication
- Auto-refresh expired tokens
- Handle 401/403 responses

#### Step 26: Implement Command Registry

**File:** `cli/src/commands/CommandRegistry.ts`

**Actions:**

- Fetch plugin metadata from server
- Dynamically generate commands from capabilities
- Add arguments from capability schemas
- Route to capability execution

#### Step 27: Create Core Commands

**File:** `cli/src/commands/CoreCommands.ts`

**Actions:**

- `pab login` - Interactive login
- `pab logout` - Clear credentials
- `pab whoami` - Show current user
- `pab config` - Manage configuration
- `pab plugins` - List/show plugins
- `pab capabilities` - List capabilities

#### Step 28: Implement Output Formatters

**File:** `cli/src/formatters/OutputFormatter.ts`

**Actions:**

- Table formatter (cli-table3)
- JSON formatter (pretty-print)
- YAML formatter
- Human-readable formatter

#### Step 29: Build Main CLI Entry Point

**File:** `cli/src/index.ts`

**Actions:**

- Shebang for executable
- Load core commands
- Dynamically load plugin commands
- Handle global options (--debug)

#### Step 30: Add Shell Completions

**Files:**

- `cli/completions/pab.bash`
- `cli/completions/pab.zsh`
- `cli/completions/pab.fish`

**Actions:**

- Generate completion scripts
- Add `pab completion` command
- Installation instructions

### Phase 6: Plugin Migration & Testing (Week 8)

#### Step 31: Migrate Bolt Plugin

**File:** `backend/src/integrations/bolt/index.ts`

**Actions:**

- Remove old interface implementation
- Add metadata, capabilities, widgets, CLI commands
- Create frontend widgets
- Update tests

#### Step 32: Migrate PuppetDB Plugin

**File:** `backend/src/integrations/puppetdb/index.ts`

**Actions:**

- Similar migration to new interface
- Add widgets for reports, events
- Register CLI commands

#### Step 33: Migrate Puppetserver Plugin

**File:** `backend/src/integrations/puppetserver/index.ts`

**Actions:**

- Migrate to new interface
- Add catalog viewer widget

#### Step 34: Migrate Hiera Plugin

**File:** `backend/src/integrations/hiera/index.ts`

**Actions:**

- Migrate to new interface
- Create key explorer widget
- Declare PuppetDB dependency

#### Step 35: Create Example External Plugin

**Directory:** `examples/@pabawi-plugins/ansible/`

**Purpose:** Demonstrate third-party plugin development

**Contents:**

- Complete plugin with backend + frontend + CLI
- Documentation
- Tests

#### Step 36: Comprehensive Testing

**Actions:**

- Unit tests for all new services
- Integration tests for auth flow, plugin loading
- E2E tests for Web UI, API, CLI
- Security tests for RBAC enforcement
- Performance tests for plugin loading
- Database adapter tests

### Phase 7: Documentation & Polish (Week 9)

#### Step 37: Write Documentation

**Files:**

- `docs/plugin-development.md`
- `docs/plugin-frontend-development.md`
- `docs/cli.md`
- `docs/rbac.md`
- `docs/database.md` (new - document database abstraction)
- `docs/configuration.md` (update)
- `docs/migration-guide.md` (0.x â†’ 1.0)

#### Step 38: Create Migration Scripts

**File:** `scripts/migrate-to-v1.sh`

**Actions:**

- Convert env vars to YAML
- Create default admin user
- Backup existing data
- Migrate database schema

#### Step 39: Update Build & CI/CD

**Actions:**

- Update GitHub Actions workflows
- Add CLI build/test steps
- Update Docker images to include CLI
- Multi-arch builds
- Database adapter testing

## Breaking Changes from v0.x

1. **Plugin Interface**: Complete rewrite - all plugins must be updated
2. **Configuration**: Env vars still supported but YAML recommended
3. **Authentication**: Now required (can be disabled via config)
4. **API**: Some endpoints restructured around capabilities
5. **Frontend**: Widget system replaces hardcoded components
6. **CLI**: New CLI replaces any previous scripts
7. **Database**: Abstracted - SQLite still default but prepared for alternatives

## Migration Path

1. Backup existing Pabawi installation
2. Install v1.0.0
3. Run migration script to convert config
4. Create admin user
5. Test authentication
6. Verify plugins loaded
7. Test database migration
8. Update custom integrations (if any)

## Rollback Plan

Keep v0.x backup available. If issues arise:

1. Stop v1.0.0 server
2. Restore v0.x code and data
3. Restart v0.x server

## Database Strategy

### Current Implementation (v1.0.0)

- **SQLite**: Default and primary database
- **Adapter Pattern**: All database code abstracted behind `DatabaseAdapter` interface
- **Migration Support**: Version-tracked migrations work across adapters

### Future Database Support (v1.1+)

The abstraction layer enables adding:

1. **PostgreSQL**: For production deployments with high concurrency
   - Connection pooling
   - Better concurrent write performance
   - Advanced features (JSONB, full-text search)

2. **MySQL/MariaDB**: For organizations standardized on MySQL
   - Wide deployment support
   - Cloud provider compatibility

3. **Migration Path**:
   - Export data from SQLite
   - Initialize new database with schema
   - Import data via adapter
   - Update configuration

### Database Adapter Implementation Checklist

When adding a new database adapter:

- [ ] Implement `DatabaseAdapter` interface
- [ ] Handle dialect-specific SQL syntax
- [ ] Implement connection pooling
- [ ] Support transactions properly
- [ ] Write migration compatibility layer
- [ ] Add comprehensive tests
- [ ] Document configuration options
- [ ] Update factory to support new type

## CLI Synopsis Examples

```bash
# Core commands
pab login
pab logout  
pab whoami
pab config set output.format json
pab plugins list
pab capabilities

# Plugin commands (auto-generated from bolt plugin)
pab bolt run "uptime" --targets all
pab bolt task package --targets web-* --params '{"action":"install","name":"nginx"}'
pab bolt inventory

# Plugin commands (auto-generated from puppetdb plugin)
pab puppetdb facts web-01
pab puppetdb query "nodes { certname ~ 'web' }"
pab puppetdb reports --status failed --since 1h

# Plugin commands (auto-generated from hiera plugin)
pab hiera lookup ntp_servers --node web-01 --environment production
pab hiera keys --pattern '*password*'

# Debug mode
pab --debug bolt run "systemctl status nginx" --targets web-01

# Different output formats
pab bolt inventory --format table
pab bolt inventory --format json | jq '.[] | .certname'

# RBAC enforcement (user with viewer role)
$ pab bolt run "reboot" --targets all
âœ— Permission denied: You lack the 'command.execute' capability.
```

## Success Metrics

- All existing integrations (Bolt, PuppetDB, Puppetserver, Hiera) migrated
- Example external plugin working
- RBAC functioning across Web UI, API, CLI
- Debug mode tracking working
- CLI commands auto-generated from plugins
- Database abstraction layer complete with SQLite adapter
- Documentation complete
- All tests passing
- Migration from v0.x successful

## Timeline

- **Weeks 1-2:** Core plugin infrastructure + database abstraction
- **Week 3:** Authentication & authorization
- **Week 4:** Configuration system
- **Weeks 5-6:** Frontend plugin system
- **Week 7:** CLI application
- **Week 8:** Plugin migration & testing
- **Week 9:** Documentation & polish
- **Total:** 9 weeks to v1.0.0 release

## Future Considerations (v1.1+)

1. **Plugin Marketplace**: Registry for third-party plugins
2. **Hot Reload**: Reload plugins without server restart (production-safe)
3. **Multi-Tenancy**: Organization/tenant support
4. **SSO/LDAP**: Enterprise authentication
5. **Service Accounts**: API tokens for automation
6. **Widget Configuration UI**: Drag-and-drop dashboard builder
7. **Plugin Sandboxing**: Security isolation for untrusted plugins
8. **CLI Server Profiles**: Manage multiple Pabawi servers
9. **Streaming Output**: Real-time command output in CLI
10. **Plugin Dependencies**: Automatic dependency installation
11. **PostgreSQL Adapter**: Production-ready database backend
12. **MySQL Adapter**: Alternative database option
13. **Database Migration Tools**: GUI for database upgrades
14. **Multi-Database Support**: Read replicas, sharding

## Notes

### Database Abstraction Rationale

The database abstraction layer provides:

- **Flexibility**: Easy to switch databases based on deployment needs
- **Testing**: Mock adapters for unit tests without actual database
- **Performance**: Can optimize per-database (e.g., PostgreSQL JSONB for plugin configs)
- **Scalability**: Future support for read replicas, connection pooling strategies
- **Migration**: Smooth path from SQLite (development) to PostgreSQL (production)

SQLite remains the default for its simplicity and zero-configuration setup, making Pabawi easy to deploy for small teams and development. The abstraction ensures larger deployments can migrate to PostgreSQL without code changes.

---

**End of Plan Document**
